"""
Game Specification Schema - Game-Agnostic DSL

This module defines the schema for game specifications that can be:
1. Hand-authored for MVP
2. Generated by LLM from rules text
3. Validated against JSON schema
4. Loaded by the engine at runtime
"""

from __future__ import annotations
from dataclasses import dataclass, field
from enum import Enum
from typing import Any

from .effect_dsl import Effect


class PhaseType(Enum):
    """Standard phase types in a turn."""
    SETUP = "setup"
    DRAW = "draw"
    ACTION = "action"
    CLEANUP = "cleanup"
    END = "end"


class WinConditionType(Enum):
    """Types of win conditions."""
    ACHIEVEMENT_COUNT = "achievement_count"
    SCORE_THRESHOLD = "score_threshold"
    DECK_EXHAUSTION = "deck_exhaustion"
    CUSTOM = "custom"


@dataclass
class ResourceDefinition:
    """Defines a resource type in the game (icons, tokens, etc.)."""
    name: str
    icon: str | None = None
    description: str = ""


@dataclass
class ZoneDefinition:
    """Defines a zone where cards/components can exist."""
    name: str
    owner: str  # "player", "shared", "none"
    visibility: str  # "public", "private", "hidden"
    ordered: bool = False
    max_size: int | None = None
    layout: str | None = None  # For games like Innovation: "stack", "splay_left", etc.


@dataclass
class CardDefinition:
    """Schema for card definitions within a game spec."""
    id: str
    name: str
    age: int | None = None  # Innovation-specific but generalizable as "tier"
    color: str | None = None
    icons: dict[str, int] = field(default_factory=dict)
    effects: list[Effect] = field(default_factory=list)
    keywords: list[str] = field(default_factory=list)
    metadata: dict[str, Any] = field(default_factory=dict)


@dataclass
class ActionDefinition:
    """Defines a legal action type in the game."""
    name: str
    description: str
    phases: list[str]  # Which phases this action is available
    cost: dict[str, Any] | None = None
    preconditions: list[str] = field(default_factory=list)  # Condition expressions
    effects: list[Effect] = field(default_factory=list)
    parameters: dict[str, str] = field(default_factory=dict)  # param_name -> type


@dataclass
class PhaseDefinition:
    """Defines a phase in the turn structure."""
    name: str
    phase_type: PhaseType
    actions_allowed: int | None = None  # None = unlimited
    mandatory_actions: list[str] = field(default_factory=list)
    optional_actions: list[str] = field(default_factory=list)
    auto_effects: list[Effect] = field(default_factory=list)  # Effects that trigger automatically


@dataclass
class TurnStructure:
    """Defines how turns flow in the game."""
    phases: list[PhaseDefinition]
    actions_per_turn: int | None = None
    can_pass: bool = True
    turn_order: str = "clockwise"  # "clockwise", "counter_clockwise", "custom"


@dataclass
class WinCondition:
    """Defines how to win the game."""
    condition_type: WinConditionType
    threshold: int | None = None
    description: str = ""
    check_expression: str | None = None  # For custom conditions


@dataclass
class GameSpec:
    """
    Complete game specification - the canonical artifact that the engine loads.

    This is the output of the rule compiler and the input to the engine.
    It must be:
    - Serializable to JSON/YAML
    - Validatable against a schema
    - Version-controlled
    - Sufficient to play the game without additional rules text
    """
    game_id: str
    game_name: str
    version: str
    min_players: int
    max_players: int

    # Component definitions
    resources: list[ResourceDefinition] = field(default_factory=list)
    zones: list[ZoneDefinition] = field(default_factory=list)
    cards: list[CardDefinition] = field(default_factory=list)

    # Turn and action structure
    turn_structure: TurnStructure | None = None
    actions: list[ActionDefinition] = field(default_factory=list)

    # Victory
    win_conditions: list[WinCondition] = field(default_factory=list)

    # Setup
    setup_effects: list[Effect] = field(default_factory=list)

    # Metadata
    metadata: dict[str, Any] = field(default_factory=dict)

    def get_card(self, card_id: str) -> CardDefinition | None:
        """Look up a card by ID."""
        for card in self.cards:
            if card.id == card_id:
                return card
        return None

    def get_action(self, action_name: str) -> ActionDefinition | None:
        """Look up an action definition by name."""
        for action in self.actions:
            if action.name == action_name:
                return action
        return None

    def get_zone(self, zone_name: str) -> ZoneDefinition | None:
        """Look up a zone definition by name."""
        for zone in self.zones:
            if zone.name == zone_name:
                return zone
        return None
